/* polygonchart.js@v0.0.1 (es) */function PolygonChart(a){var b=Math.sin,c=Math.cos,d=Math.PI;const e=this,f=a=>parseFloat(a)*d/180,g={makeCircle:(a={})=>{const b=Object.assign({fill:"transparent",stroke:"none",radius:0,strokeWidth:"0"},a),c=g.createSVGElement("circle");return c.setAttribute("fill",b.fill),c.setAttribute("stroke",b.stroke),c.setAttribute("r",b.radius),c.setAttribute("stroke-width",b.strokeWidth),c.setAttribute("stroke-linecap","round"),c},makeLabel:a=>{const b=Object.assign({text:"",x:0,y:0,color:"",fontFamily:"sans-serif",fontSize:"7px"},a),c=g.createSVGElement("text");return c.setAttribute("text-anchor","middle"),c.setAttribute("font-family",b.fontFamily),c.setAttribute("font-size",b.fontSize),c.setAttribute("fill",b.color),c.setAttribute("x",b.x),c.setAttribute("y",b.y),c.textContent=b.text,c},makePolygon:(a=[],b)=>{const c=Object.assign({fill:"#000",stroke:"#000",strokeWidth:"1px"},b),d=g.createSVGElement("polygon");return d.setAttribute("stroke-linecap","round"),d.setAttribute("points",a),d.setAttribute("fill",c.fill),d.setAttribute("stroke",c.stroke),d.setAttribute("stroke-width",c.strokeWidth),d},getSVG:(a=0)=>{const b=2*parseFloat(a),c=g.createSVGElement("svg","polygonchart");return c.setAttribute("xmlns","http://www.w3.org/2000/svg"),c.setAttribute("polygonchart",""),c.setAttribute("height",`${b}px`),c.setAttribute("width",`${b}px`),c.setAttribute("viewBox",`0 0 ${b} ${b}`),c},createSVGElement:(a,b)=>{const c=document.createElementNS("http://www.w3.org/2000/svg",a);return b&&c.setAttribute("data-name",b),c}};//
e.options=Object.assign({radius:0,data:{data:[],sides:0,tooltips:{roundTo:0,percentage:!1},colors:{normal:{polygonStroke:"#1e3d96",polygonFill:"rgba(39, 78, 192,.5)",pointStroke:"transparent",pointFill:"#1e3d96"},onHover:{polygonStroke:"#1a3480",polygonFill:"rgba(39, 78, 192,.85)",pointStroke:"transparent",pointFill:"#1a3480"}}},polygon:{colors:{normal:{fill:"#fff",stroke:"#8c8c8c"},onHover:{splineFill:"#fff",splineStroke:"#000"}}},levels:{count:5,labels:{enabled:!0,position:{spline:1,quadrant:0},colors:{normal:"#8c8c8c",onHover:"#000"}}},tippy:{},anime:{duration:1e4,easing:"linear"},animation:{autoplay:!1}},a),e.svg=null,e.animations=[];let h,j,k,l=[],n=[],o=[],p=-1,q=-1,r=-1,s=-1,t=-1;//
const u={onEnterDataPoint:a=>{a.setAttribute("fill",e.options.data.colors.onHover.pointFill),a.setAttribute("stroke",e.options.data.colors.onHover.pointStroke)},onLeaveDataPoint:a=>{a.setAttribute("fill",e.options.data.colors.normal.pointFill),a.setAttribute("stroke",e.options.data.colors.normal.pointStroke)},onEnterSpline:a=>{a.setAttribute("fill",e.options.polygon.colors.onHover.fill),a.setAttribute("stroke",e.options.polygon.colors.onHover.stroke);const b=a.getAttribute("index"),c=j.querySelector(`text[index='${b}']`);c&&c.setAttribute("fill",e.options.levels.labels.colors.onHover)},onLeaveSpline:a=>{a.setAttribute("fill",e.options.polygon.colors.normal.fill),a.setAttribute("stroke",e.options.polygon.colors.normal.stroke);const b=a.getAttribute("index"),c=j.querySelector(`text[index='${b}']`);c&&c.setAttribute("fill",e.options.levels.labels.colors.normal)},onEnterDataPoly:a=>{a.setAttribute("fill",e.options.data.colors.onHover.polygonFill),a.setAttribute("stroke",e.options.data.colors.onHover.polygonStroke)},onLeaveDataPoly:a=>{a.setAttribute("fill",e.options.data.colors.normal.polygonFill),a.setAttribute("stroke",e.options.data.colors.normal.polygonStroke)}},v=()=>{const a=g.createSVGElement("g","data"),b=g.createSVGElement("g","data-points");for(let a=1;a<=e.options.data.sides;a++){const c=g.createSVGElement("g",`point-${a}`),d=g.makeCircle({radius:10}),f=g.makeCircle({fill:e.options.data.colors.normal.pointFill,stroke:e.options.data.colors.normal.pointStroke,radius:4,strokeWidth:"2px"});c.appendChild(d),c.appendChild(f),b.appendChild(c),c.addEventListener("mouseenter",u.onEnterDataPoint.bind(this,f)),c.addEventListener("touchstart",u.onEnterDataPoint.bind(this,f)),c.addEventListener("mouseleave",u.onLeaveDataPoint.bind(this,f)),c.addEventListener("touchend",u.onLeaveDataPoint.bind(this,f)),c.style.setProperty("cursor","pointer"),l.push(c)}a.appendChild(k),e.svg.appendChild(a),e.svg.appendChild(b)},w=()=>{const{radius:a}=e.options;for(let d,g=0;g<e.options.data.data.length;g++){d="";for(let h=1,i=0;h<=e.options.data.sides;h++,i++){const j=f(t*h-q),k=a*e.options.data.data[g][i]*c(j)+a,l=a*e.options.data.data[g][i]*b(j)+a;d+=`${k},${l} `,Array.isArray(n[i])||(n[i]=[]),n[i].push({x:k,y:l})}o.push(d)}},x=(a=-1)=>{const{radius:d}=e.options;let g="";for(let h=1,i=0;h<=e.options.data.sides;h++,i++){const j=f(t*h-q),k=d*e.options.data.data[a][i]*c(j)+d,m=d*e.options.data.data[a][i]*b(j)+d;g+=`${k},${m} `;let n=e.options.data.data[a][i];e.options.data.tooltips.percentage&&(n*=100),e.options.data.tooltips.roundTo&&(n=n.toFixed(e.options.data.tooltips.roundTo));const o=`${n}${e.options.data.tooltips.percentage?"%":""}`;l[i].style.setProperty("transform",`translateX(${k}px) translateY(${m}px)`),l[i].setAttribute("data-value",n),l[i].setAttribute("data-tippy-content",o)}k.setAttribute("points",g)},y=(a={})=>{const{radius:d,levels:i}=a;let k;i===e.options.levels.count&&(k=g.createSVGElement("g","crosshairs"));let l="",m=-1;for(let g=1;g<=e.options.data.sides;g++){const a=f(t*g-q),h=d*c(a)+e.options.radius,j=d*b(a)+e.options.radius;/* + appended space */if(m=j,l+=`${h},${j} `,i===e.options.levels.count){const d=s*c(a)+e.options.radius,f=s*b(a)+e.options.radius,g=r*c(a)+e.options.radius,h=r*b(a)+e.options.radius,i=document.createElementNS("http://www.w3.org/2000/svg","line");i.setAttribute("stroke",e.options.polygon.colors.normal.stroke),i.setAttribute("x1",d),i.setAttribute("y1",f),i.setAttribute("x2",g),i.setAttribute("y2",h),k&&k.appendChild(i)}}const n=100/e.options.levels.count*i,o=`${n}%`,p=`${e.options.radius}px`,v=`${m-2}px`,w=6*(o.length-1),x=`${m-2+w}px`,z=180/e.options.data.sides,A=g.makeLabel({text:o,x:p,y:v,color:e.options.levels.labels.colors.normal});if(A.setAttribute("index",i),0!==e.options.levels.labels.position.quadrant);else 0!==e.options.levels.labels.position.spline&&(A.style.setProperty("transform-origin",`${p} ${x}`),A.style.setProperty("transform",`rotateZ(${-z}deg)`));j.appendChild(A);const B=g.makePolygon(l,{stroke:e.options.polygon.colors.normal.stroke,fill:e.options.polygon.colors.normal.fill});// additional inner polygon ...
if(B.setAttribute("index",i),B.addEventListener("mouseenter",u.onEnterSpline.bind(this,B)),B.addEventListener("touchstart",u.onEnterSpline.bind(this,B)),B.addEventListener("mouseleave",u.onLeaveSpline.bind(this,B)),B.addEventListener("touchend",u.onLeaveSpline.bind(this,B)),h.appendChild(B),0<i){const a=d-e.options.radius/e.options.levels.count,b=0<=i-1?i-1:0;y({radius:a,levels:b})}e.svg.appendChild(h),i===e.options.levels.count&&e.svg.appendChild(k),e.svg.appendChild(j)},z=()=>{const a=180/e.options.data.sides;let b=0;0===e.options.levels.labels.position.quadrant?0!==e.options.levels.labels.position.spline&&(b=2*a*e.options.levels.labels.position.spline):b=a+2*a*(e.options.levels.labels.position.quadrant-1),j.style.setProperty("transform-origin",`${e.options.radius}px ${e.options.radius}px`),j.style.setProperty("transform",`rotateZ(${b}deg)`)},A=()=>{const a=e.options.target.querySelector("[polygonchart]");a&&a.remove(),l=[],n=[],o=[],h=g.createSVGElement("g","splines"),j=g.createSVGElement("g","labels"),e.svg=g.getSVG(e.options.radius),k=g.makePolygon("",{fill:e.options.data.colors.normal.polygonFill,stroke:e.options.data.colors.normal.polygonStroke}),k.addEventListener("mouseenter",u.onEnterDataPoly.bind(this,k)),k.addEventListener("touchstart",u.onEnterDataPoly.bind(this,k)),k.addEventListener("mouseleave",u.onLeaveDataPoly.bind(this,k)),k.addEventListener("touchend",u.onLeaveDataPoly.bind(this,k)),p=0==e.options.data.sides%2,q=p?360/(2*e.options.data.sides):90,r=e.options.radius,s=e.options.radius/e.options.levels.count,t=360/e.options.data.sides,e.options.target.appendChild(e.svg)},B=()=>{// : todo :
const a=anime({...e.options.anime,targets:k,autoplay:!1,points:o.map(a=>({value:a}))});e.animations.push(a);for(let a=0;a<l.length;a++){const b=l[a],c=n[a];if(c){// : todo :
const a=anime({...e.options.anime,targets:b,autoplay:!1,translateX:c.map(({x:a})=>({value:a})),translateY:c.map(({y:a})=>({value:a}))});e.animations.push(a)}}e.options.animation.autoplay&&e.start()};//
return e.init=()=>(A(),y({levels:e.options.levels.count,radius:e.options.radius}),v(),x(0),w(),z(),B(),tippy("[data-tippy-content]",e.options.tippy),e),e.startAnimation=()=>{const{animations:a}=e;for(let b=0;b<a.length;b++)a[b].play();return e},e.resetAnimation=()=>{const{animations:b}=e;for(let c=0;c<b.length;c++){const d=b[c];d.restart(),d.pause()}return e},e.stopAnimation=()=>{const{animations:a}=e;for(let b=0;b<a.length;b++)a[b].pause();return e},e.seekAnimation=(a=0)=>{const{animations:b}=e;for(let c=0;c<b.length;c++)b[c].seek(a);return e},e.reload=()=>(e.init(),e),e}export default PolygonChart;
